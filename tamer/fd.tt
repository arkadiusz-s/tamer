// -*- mode: c++ -*-
/* Copyright (c) 2007, Eddie Kohler
 * Copyright (c) 2007, Regents of the University of California
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, subject to the conditions
 * listed in the Tamer LICENSE file. These conditions include: you must
 * preserve this copyright notice, and you cannot mention the copyright
 * holders in advertising related to the Software without their permission.
 * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
 * notice is a summary of the Tamer LICENSE file; the license in that file is
 * legally binding.
 */
#include <tamer/fd.hh>
#include <sys/select.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <tamer/tamer.hh>
#include <tamer/fdh.hh>

namespace tamer {

fdhlist _fdhl;

size_t fd::garbage_size;

int fd::make_nonblocking(int f)
{
    int flags = 1;
    if (::ioctl(f, FIONBIO, &flags) == 0)
	return 0;
    flags = ::fcntl(f, F_GETFL);
    if (flags < 0)
	return flags;
    return ::fcntl(f, F_SETFL, flags | O_NONBLOCK);
}

event<> fd::closer()
{
    if (*this) {
	event<> e = fun_event(fdcloser(_p));
	at_close(e);
	return e;
    } else
	return event<>();
}

tamed static void fd::open(const char *filename, int flags, mode_t mode, event<fd> done)
{
  tvars { int f(); fd nfd; }
  twait { _fdhl.get().open(filename, flags | O_NONBLOCK, mode, make_event(f)); }
  nfd = fd(f);
  nfd._p->_is_file = true;
  done.trigger(nfd);
}

void fd::fdimp::fstat(struct stat &stat_out, event<int> done)
{
  _fdhl.get().fstat(_fd, stat_out, done);
}

tamed void fd::fdimp::read(void *buf, size_t size, size_t &size_out, event<int> done)
{
    tvars {
	size_t pos = 0;
	ssize_t amt;
	passive_ref_ptr<fd::fdimp> hold(this);
    int fd;
    rendezvous<> r;
    event<> e;
    }
    
    if (_fd < 0) {
	done.trigger(-EBADF);
	return;
    }
    
    fd = _fd;
    if (_is_file) {
      e = make_event(r);
      twait { _fdhl.get().read(_fd, size, make_event(fd), e); }
    }

    twait { _rlock.acquire(make_event()); }
    
    while (pos != size && (_is_file || (done && fd >= 0))) {
      //if _is_file we must read until the end
	amt = ::read(fd, static_cast<char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait { tamer::at_fd_read(fd, make_event()); }
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    break;
	}
    }
    
    if (e)
      e.trigger();

    _rlock.release();
    done.trigger(pos == size || _fd >= 0 ? 0 : -ECANCELED);
}

tamed void fd::fdimp::read_once(void *buf, size_t size, size_t &size_out, event<int> done)
{
    tvars {
	ssize_t amt;
	passive_ref_ptr<fd::fdimp> hold(this);
    }
    
    if (_fd < 0) {
	done.trigger(-EBADF);
	return;
    }

    twait { _rlock.acquire(make_event()); }
    
    while (done && _fd >= 0) {
	amt = ::read(_fd, static_cast<char *>(buf), size);
	if (amt != 0 && amt != (ssize_t) -1) {
	    size_out = amt;
      break;
  } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait { tamer::at_fd_read(_fd, make_event()); }
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    break;
	}
    }
    
    _rlock.release();
    done.trigger(0);
}

tamed void fd::fdimp::write(const void *buf, size_t size, size_t &size_out, event<int> done)
{
    tvars {
	size_t pos = 0;
	ssize_t amt;
	passive_ref_ptr<fd::fdimp> hold(this);
    int fd;
    rendezvous<> r;
    event<> e;
    }

    if (_fd < 0) {
	done.trigger(-EBADF);
	return;
    }
    
    fd = _fd;
    if (_is_file) {
      e = make_event(r);
      twait { _fdhl.get().write(_fd, size, make_event(fd), e); }
    }

    twait { _wlock.acquire(make_event()); }
    
    while (pos != size && (_is_file || (done && _fd >= 0))) {
      //if _is_file we must read until the end
	amt = ::write(_fd, static_cast<const char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait { tamer::at_fd_write(_fd, make_event()); }
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    break;
	}
    }
  
    if (e)
      e.trigger();

    _wlock.release();
    done.trigger(pos == size || _fd >= 0 ? 0 : -ECANCELED);
}

tamed void fd::fdimp::write(std::string s, size_t &size_out, event<int> done)
{
    twait {
	done.at_trigger(make_event());
	write(s.data(), s.length(), size_out, done);
    }
}

fd fd::socket(int domain, int type, int protocol)
{
    int f = ::socket(domain, type, protocol);
    if (f >= 0)
	make_nonblocking(f);
    return fd(f == -1 ? -errno : f);
}

int fd::listen(int backlog)
{
    if (*this)
	return (::listen(_p->_fd, backlog) == 0 ? 0 : -errno);
    else
	return -EBADF;
}

int fd::bind(const struct sockaddr *addr, socklen_t addrlen)
{
    if (*this)
	return (::bind(_p->_fd, addr, addrlen) == 0 ? 0 : -errno);
    else
	return -EBADF;
}

tamed void fd::fdimp::accept(struct sockaddr *addr_out, socklen_t *addrlen_out, event<fd> done)
{
    tvars {
	int f = -ECANCELED;
	passive_ref_ptr<fd::fdimp> hold(this);
    }

    if (_fd < 0) {
	done.trigger(fd());
	return;
    }

    twait { _rlock.acquire(make_event()); }
    
    while (done && _fd >= 0) {
	f = ::accept(_fd, addr_out, addrlen_out);
	if (f >= 0) {
	    make_nonblocking(f);
	    break;
	} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait { tamer::at_fd_read(_fd, make_event()); }
	} else if (errno != EINTR) {
	    f = -errno;
	    break;
	}
    }

    _rlock.release();
    done.trigger(fd(f));
}

tamed void fd::fdimp::connect(const struct sockaddr *addr, socklen_t addrlen, event<int> done)
{
    tvars {
	int x, ret(0);
	passive_ref_ptr<fd::fdimp> hold(this);
    }

    if (_fd < 0) {
	done.trigger(-EBADF);
	return;
    }

    twait { _wlock.acquire(make_event()); }
    
    x = ::connect(_fd, addr, addrlen);
    if (x == -1 && errno != EINPROGRESS)
	ret = -errno;
    else if (x == -1) {
	twait { tamer::at_fd_write(_fd, make_event()); }
	socklen_t socklen = sizeof(x);
	if (!done || _fd < 0)
	    ret = -ECANCELED;
	else if (getsockopt(_fd, SOL_SOCKET, SO_ERROR, (void *) &x, &socklen) == -1)
	    ret = -errno;
	else if (ret > 0)
	    ret = -x;
    }

    _wlock.release();
    done.trigger(ret);
}


int fd::fdimp::close(int leave_error)
{
    int my_fd = _fd;
    if (my_fd >= 0 || leave_error != -EBADF)
	_fd = leave_error;
    if (my_fd >= 0) {
	int x = ::close(my_fd);
	if (x == -1) {
	    x = -errno;
	    if (_fd == -EBADF)
		_fd = -errno;
	}
	driver::main->kill_fd(my_fd);
	_at_close.trigger();
	_at_close = event<>();
	return x;
    } else
	return -EBADF;
}

void fd::close(event<int> done)
{
    done.trigger(*this ? _p->close() : -EBADF);
}


namespace fdx {

void tcp_listen(int port, int backlog, event<fd> result)
{
    fd f = fd::socket(AF_INET, SOCK_STREAM, 0);
    if (f) {
	// Default to reusing port addresses.  Don't worry if it fails
	int yes = 1;
	(void) setsockopt(f.value(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

	struct sockaddr_in saddr;
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(port);
	saddr.sin_addr.s_addr = INADDR_ANY;
	int ret = f.bind((struct sockaddr *) &saddr, sizeof(saddr));
	if (ret >= 0)
	    ret = f.listen(backlog);
    
	if (ret < 0 && f)
	    f.error_close(ret);
    }
    result.trigger(f);
}

tamed void tcp_connect(struct in_addr addr, int port, event<fd> result)
{
    tvars {
	fd f = fd::socket(AF_INET, SOCK_STREAM, 0);
	int ret = 0;
	struct sockaddr_in saddr;
    }
    if (f)
	twait {
	    memset(&saddr, 0, sizeof(saddr));
	    saddr.sin_family = AF_INET;
	    saddr.sin_addr = addr;
	    saddr.sin_port = htons(port);
	    f.connect((struct sockaddr *) &saddr, sizeof(saddr), make_event(ret));
	}
    if (ret < 0 && f)
	f.error_close(ret);
    result.trigger(f);
}

tamed void udp_connect(struct in_addr addr, int port, event<fd> result) {
  tvars {
    fd f = fd::socket(AF_INET, SOCK_DGRAM, 0);
	  int ret = 0;
	  struct sockaddr_in saddr;
  }
  if (f)
	  twait {
	    memset(&saddr, 0, sizeof(saddr));
	    saddr.sin_family = AF_INET;
	    saddr.sin_addr = addr;
	    saddr.sin_port = htons(port);
	    f.connect((struct sockaddr *) &saddr, sizeof(saddr), make_event(ret));
	  }
  if (ret < 0 && f)
	  f.error_close(ret);
  result.trigger(f);
}

}}
