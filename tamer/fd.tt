// -*- mode: c++ -*-
#include <tamer/fd.hh>
#include <sys/select.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <tamer/tamer.hh>
namespace tamer {

size_t fd::garbage_size;

int fd::make_nonblocking(int f)
{
    int flags = 1;
    if (::ioctl(f, FIONBIO, &flags) == 0)
	return 0;
    flags = ::fcntl(f, F_GETFL);
    if (flags < 0)
	return flags;
    return ::fcntl(f, F_SETFL, flags | O_NONBLOCK);
}

struct fd::fdcloser {
    fdcloser(fd::fdimp *f)
	: _f(f) {
	_f->weak_use();
    }
    fdcloser(const fdcloser &other)
	: _f(other._f) {
	_f->weak_use();
    }
    ~fdcloser() {
	_f->weak_unuse();
    }
    void operator()() {
	_f->close();
    }
    fd::fdimp *_f;
  private:
    fdcloser &operator=(const fdcloser &);
};

event<> fd::closer()
{
    if (*this) {
	event<> e = fun_event(fdcloser(_p));
	at_close(e);
	return e;
    } else
	return event<>();
}

void fd::open(const char *filename, int flags, mode_t mode, event<fd> done)
{
    int f = ::open(filename, flags | O_NONBLOCK, mode);
    done.trigger(fd(f == -1 ? -errno : f));
}

void fd::fstat(struct stat &stat_out, event<int> done)
{
    if (*this) {
	int x = ::fstat(value(), &stat_out);
	done.trigger(x == -1 ? -errno : 0);
    } else
	done.trigger(-EBADF);
}

tamed void fd::read(void *buf, size_t size, size_t &size_out, event<int> done)
{
    tvars {
	size_t pos = 0;
	ssize_t amt;
    }
    
    if (!*this) {
	done.trigger(-EBADF);
	return;
    }
    
    twait { _p->rlock.acquire(make_event()); }
    
    while (pos != size && done && *this) {
	amt = ::read(_p->fd, static_cast<char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait volatile { tamer::at_fd_read(_p->fd, make_event()); }
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    break;
	}
    }
    
    _p->rlock.release();
    done.trigger(pos == size || *this ? 0 : -ECANCELED);
}

tamed void fd::write(const void *buf, size_t size, size_t &size_out, event<int> done)
{
    tvars {
	size_t pos = 0;
	ssize_t amt;
    }

    if (!*this) {
	done.trigger(-EBADF);
	return;
    }
    
    twait { _p->wlock.acquire(make_event()); }
    
    while (pos != size && done && *this) {
	amt = ::write(_p->fd, static_cast<const char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait volatile { tamer::at_fd_write(_p->fd, make_event()); }
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    break;
	}
    }
    
    _p->wlock.release();
    done.trigger(pos == size || *this ? 0 : -ECANCELED);
}

tamed void fd::write(std::string s, size_t &size_out, event<int> done)
{
    twait {
	done.at_trigger(make_event());
	write(s.data(), s.length(), size_out, done);
    }
}

fd fd::socket(int domain, int type, int protocol)
{
    int f = ::socket(domain, type, protocol);
    if (f >= 0)
	make_nonblocking(f);
    return fd(f == -1 ? -errno : f);
}

int fd::listen(int backlog)
{
    if (!*this)
	return -EBADF;
    else
	return (::listen(_p->fd, backlog) == 0 ? 0 : -errno);
}

int fd::bind(const struct sockaddr *addr, socklen_t addrlen)
{
    if (!*this)
	return -EBADF;
    else
	return (::bind(_p->fd, addr, addrlen) == 0 ? 0 : -errno);
}

tamed void fd::accept(struct sockaddr *addr_out, socklen_t *addrlen_out, event<fd> done)
{
    tvars {
	int f = -ECANCELED;
    }

    if (!*this) {
	done.trigger(fd());
	return;
    }

    twait { _p->rlock.acquire(make_event()); }
    
    while (done && *this) {
	f = ::accept(_p->fd, addr_out, addrlen_out);
	if (f >= 0) {
	    make_nonblocking(f);
	    break;
	} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    twait volatile { tamer::at_fd_read(_p->fd, make_event()); }
	} else if (errno != EINTR) {
	    f = -errno;
	    break;
	}
    }

    _p->rlock.release();
    done.trigger(fd(f));
}

tamed void fd::connect(const struct sockaddr *addr, socklen_t addrlen, event<int> done)
{
    tvars {
	int x, ret(0);
    }

    if (!*this) {
	done.trigger(-EBADF);
	return;
    }
    
    twait { _p->wlock.acquire(make_event()); }
    
    x = ::connect(_p->fd, addr, addrlen);
    if (x == -1 && errno != EINPROGRESS)
	ret = -errno;
    else if (x == -1) {
	twait volatile { tamer::at_fd_write(_p->fd, make_event()); }
	socklen_t socklen = sizeof(x);
	if (!done || !*this)
	    ret = -ECANCELED;
	else if (getsockopt(_p->fd, SOL_SOCKET, SO_ERROR, (void *) &x, &socklen) == -1)
	    ret = -errno;
	else if (ret > 0)
	    ret = -x;
    }

    _p->wlock.release();
    done.trigger(ret);
}


int fd::fdimp::close(int leave_error)
{
    if (fd >= 0) {
	int my_fd = fd;
	fd = leave_error;
	int x = ::close(my_fd);
	if (x == -1)
	    x = fd = -errno;
	driver::main->kill_fd(my_fd);
	at_close.trigger();
	at_close = event<>();
	return x;
    } else
	return -EBADF;
}

void fd::close(event<int> done)
{
    done.trigger(*this ? _p->close() : -EBADF);
}

void fd::tcp_listen(int port, int backlog, event<fd> result)
{
    fd f = fd::socket(AF_INET, SOCK_STREAM, 0);
    if (f) {
	// Default to reusing port addresses.  Don't worry if it fails
	int yes = 1;
	(void) setsockopt(f.value(), SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

	struct sockaddr_in saddr;
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(port);
	saddr.sin_addr.s_addr = INADDR_ANY;
	int ret = f.bind((struct sockaddr *) &saddr, sizeof(saddr));
	if (ret >= 0)
	    ret = f.listen(backlog);
    
	if (ret < 0 && f)
	    f._p->close(ret);
    }
    result.trigger(f);
}

tamed static void fd::tcp_connect(struct in_addr addr, int port,
				  event<fd> result)
{
    tvars {
	fd f = fd::socket(AF_INET, SOCK_STREAM, 0);
	int ret = 0;
	struct sockaddr_in saddr;
    }
    if (f)
	twait volatile {
	    memset(&saddr, 0, sizeof(saddr));
	    saddr.sin_family = AF_INET;
	    saddr.sin_addr = addr;
	    saddr.sin_port = htons(port);
	    f.connect((struct sockaddr *) &saddr, sizeof(saddr), make_event(ret));
	}
    if (ret < 0 && f)
	f._p->close(ret);
    result.trigger(f);
}

}
