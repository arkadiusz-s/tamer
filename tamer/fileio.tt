// -*- mode: c++ -*-
#include <tamer/fileio.hh>
#include <sys/select.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

namespace tamer {
namespace fileio {

int make_nonblocking(int fd)
{
    int flags = 1;
    if (::ioctl(fd, FIONBIO, &flags) == 0)
	return 0;
    flags = ::fcntl(fd, F_GETFL);
    if (flags < 0)
	return flags;
    return ::fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

void open(const char *filename, int flags, mode_t mode, event<int> done)
{
    int fd = ::open(filename, flags | O_NONBLOCK, mode);
    done.trigger(fd == -1 ? -errno : fd);
}

tamed void read(int fd, void *buf, size_t size, ssize_t &size_out, event<int> done)
{
    tvars {
	size_t pos(0);
	ssize_t amt;
	rendezvous<> r;
    }
    done.at_cancel(make_event(r));
    while (pos != size && done) {
	amt = ::read(fd, static_cast<char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_read(fd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(0);
}

tamed void write(int fd, const void *buf, size_t size, ssize_t &size_out, event<int> done)
{
    tvars {
	size_t pos(0);
	ssize_t amt;
	rendezvous<> r;
    }
    done.at_cancel(make_event(r));
    while (pos != size && done) {
	amt = ::write(fd, static_cast<const char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_write(fd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(0);
}

tamed void close(int fd)
{
    ::close(fd);
}

tamed void fstat(int fd, struct stat &stat_out, event<int> done)
{
    int ret = ::fstat(fd, &stat_out);
    done.trigger(ret == -1 ? -errno : 0);
}

tamed void pipe(int fd_out[2], event<int> done)
{
    int ret = ::pipe(fd_out);
    if (ret >= 0) {
	make_nonblocking(fd_out[0]);
	make_nonblocking(fd_out[1]);
    }
    done.trigger(ret == -1 ? -errno : 0);
}

void socket(int domain, int type, int protocol, event<int> done)
{
    int fd = ::socket(domain, type, protocol);
    if (fd >= 0)
	make_nonblocking(fd);
    done.trigger(fd >= 0 ? fd : -errno);
}

tamed void accept(int listenfd, struct sockaddr *name_out, socklen_t *namelen_out, event<int> done)
{
    tvars {
	int fd(-1);
	rendezvous<> r;
    }
    done.at_cancel(make_event(r));
    while (done) {
	fd = ::accept(listenfd, name_out, namelen_out);
	if (fd >= 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_read(listenfd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(fd >= 0 ? fd : -errno);
}

tamed void connect(int fd, const struct sockaddr *name, socklen_t namelen, event<int> done)
{
    tvars {
	int ret;
	rendezvous<> r;
    }
    done.at_cancel(make_event(r));
    ret = ::connect(fd, name, namelen);
    if (ret == -1 && errno == EINPROGRESS) {
	tamer::at_fd_write(fd, make_event(r));
	twait(r);
	socklen_t socklen = sizeof(ret);
	if (!done)
	    return;
	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *) &ret, &socklen) == -1) {
	    done.trigger(-errno);
	    return;
	} else if (ret > 0) {
	    done.trigger(-ret);
	    return;
	}
    }
    done.trigger(ret >= 0 ? 0 : -errno);
}

}}
