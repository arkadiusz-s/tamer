// -*- mode: c++ -*-
#include <tamer/fileio.hh>
#include <sys/select.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

namespace tamer {
namespace fileio {

int make_nonblocking(int fd)
{
    int flags = 1;
    if (::ioctl(fd, FIONBIO, &flags) == 0)
	return 0;
    flags = ::fcntl(fd, F_GETFL);
    if (flags < 0)
	return flags;
    return ::fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

void open(const char *filename, int flags, mode_t mode, event<int> done)
{
    int fd = ::open(filename, flags | O_NONBLOCK, mode);
    done.trigger(fd == -1 ? -errno : fd);
}

tamed void read(int fd, void *buf, size_t size, ssize_t &size_out, event<int> done)
{
    tvars {
	size_t pos(0);
	ssize_t amt;
	rendezvous<> r;
	event<> closewatch(r);
    }
    tamer::at_fd_close(fd, closewatch);
    while (pos != size && done && closewatch) {
	amt = ::read(fd, static_cast<char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_read(fd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(pos < size || closewatch ? 0 : -ECANCELED);
}

tamed void write(int fd, const void *buf, size_t size, ssize_t &size_out, event<int> done)
{
    tvars {
	size_t pos(0);
	ssize_t amt;
	rendezvous<> r;
	event<> closewatch(r);
    }
    tamer::at_fd_close(fd, closewatch);
    while (pos != size && done && closewatch) {
	amt = ::write(fd, static_cast<const char *>(buf) + pos, size - pos);
	if (amt != 0 && amt != (ssize_t) -1) {
	    pos += amt;
	    size_out = pos;
	} else if (amt == 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_write(fd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(pos < size || closewatch ? 0 : -ECANCELED);
}

void close(int fd)
{
    driver::main.kill_fd(fd);
    ::close(fd);
}

void fstat(int fd, struct stat &stat_out, event<int> done)
{
    int x = ::fstat(fd, &stat_out);
    done.trigger(x == -1 ? -errno : 0);
}

void pipe(int fd_out[2], event<int> done)
{
    int x = ::pipe(fd_out);
    if (x >= 0) {
	make_nonblocking(fd_out[0]);
	make_nonblocking(fd_out[1]);
    }
    done.trigger(x == -1 ? -errno : 0);
}

void socket(int domain, int type, int protocol, event<int> done)
{
    int fd = ::socket(domain, type, protocol);
    if (fd >= 0)
	make_nonblocking(fd);
    done.trigger(fd == -1 ? -errno : fd);
}

tamed void accept(int listenfd, struct sockaddr *name_out, socklen_t *namelen_out, event<int> done)
{
    tvars {
	int fd(-1);
	rendezvous<> r;
	event<> closewatch(r);
    }
    tamer::at_fd_close(listenfd, closewatch);
    while (done && closewatch) {
	fd = ::accept(listenfd, name_out, namelen_out);
	if (fd >= 0)
	    break;
	else if (errno == EAGAIN || errno == EWOULDBLOCK) {
	    tamer::at_fd_read(listenfd, make_event(r));
	    twait(r);
	} else if (errno != EINTR) {
	    done.trigger(-errno);
	    return;
	}
    }
    done.trigger(fd >= 0 ? fd : -ECANCELED);
}

tamed void connect(int fd, const struct sockaddr *name, socklen_t namelen, event<int> done)
{
    tvars {
	int x, ret(0);
	rendezvous<> r;
	event<> closewatch(r);
    }
    x = ::connect(fd, name, namelen);
    if (x == -1 && errno != EINPROGRESS)
	ret = -errno;
    else if (x == -1) {
	tamer::at_fd_close(fd, closewatch);
	tamer::at_fd_write(fd, make_event(r));
	twait(r);
	socklen_t socklen = sizeof(x);
	if (!done || !closewatch)
	    ret = -ECANCELED;
	else if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *) &x, &socklen) == -1)
	    ret = -errno;
	else if (ret > 0)
	    ret = -x;
    }
    done.trigger(ret);
}

}}
