// -*- mode: c++; related-file-name: "lock.hh" -*-
#include <tamer/lock.hh>
#include <tamer/adapter.hh>
namespace tamer {

void mutex::wake()
{
    while (event<> *eptr = _waiters.front()) {
	event<> e = *eptr;
	_waiters.pop_front();
	if (e) {
	    e.trigger();
	    break;
	}
    }
}

tamed void mutex::acquire(int shared, event<> done)
{
    tvars {
	rendezvous<bool> r;
	bool result;
    }

    if (!done)
	return;
    if (!_waiters.size() && (shared > 0 ? _locked != -1 : _locked == 0)) {
	_locked += shared;
	done.trigger();
	return;
    }

    done.at_cancel(make_event(r, false));
    _waiters.push_back(make_cancel(r, false, make_event(r, true)));

    while (1) {
	twait(r, result);
	if (!result || !done) {
	    done.cancel();
	    // canceling an exclusive lock may let a shared lock through
	    r.cancel_all();
	    if (_waiters.front() && !*_waiters.front())
		wake();
	    return;
	} else if (shared > 0 ? _locked != -1 : _locked == 0) {
	    _locked += shared;
	    done.trigger();
	    if (shared > 0)	// next waiter might also want a shared lock
		wake();
	    return;
	} else
	    _waiters.push_front(make_cancel(r, false, make_event(r, true)));
    }
}

}
