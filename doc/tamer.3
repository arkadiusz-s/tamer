.TH TAMER 3 2007-04-30 Tamer "Tamer Manual"
.ds E \-\-\-
.if t .ds E \(em
.SH NAME
tamer \- C++ extensions for event-driven programming
.SH SYNOPSIS
.nf
.B #include <tamer.hh>
.B using namespace tamer;
.sp
\fBclass event<T0, T1, T2, T3> { public:
    event();
    operator bool() const;
    bool empty() const;
    void trigger(const T0 &\fIv0\fB, const T1 &\fIv1\fB,
                 const T2 &\fIv2\fB, const T3 &\fIv3\fB);
    void cancel();
    void at_cancel(const event<> &\fIcancel_evt\fB);
}
.sp
class rendezvous<I0, I1> { public:
    rendezvous();
    unsigned nevents() const;
    unsigned nready() const;
    unsigned nwaiting() const;
    bool join(I0 &\fIi0\fB, I1 &\fIi1\fB);
}
.sp
event<T0, T1, T2, T3> make_event(rendezvous<I0, I1> &\fIrendezvous\fB,
                                 const I0 &\fIi0\fB, const I1 &\fIi1\fB,
                                 T0 &\fIs0\fB, T1 &\fIs1\fB, T2 &\fIs2\fB, T3 &\fIs3\fB);
event<T0, T1, T2, T3> make_event(rendezvous<I0> &\fIrendezvous\fB,
                                 const I0 &\fIi0\fB,
                                 T0 &\fIs0\fB, T1 &\fIs1\fB, T2 &\fIs2\fB, T3 &\fIs3\fB);
event<T0, T1, T2, T3> make_event(rendezvous<> &\fIrendezvous\fB,
                                 T0 &\fIs0\fB, T1 &\fIs1\fB, T2 &\fIs2\fB, T3 &\fIs3\fB);
\&...
event<> make_event(rendezvous<I0, I1> &\fIrendezvous\fB, 
                   const I0 &\fIi0\fB, const I1 &\fIi1\fB);
event<> make_event(rendezvous<I0> &\fIrendezvous\fB, const I0 &\fIi0\fB);
event<> make_event(rendezvous<> &\fIrendezvous\fB);
.sp
tamed void user_function(...) {
    tvars { ... };
}
.sp
twait { ... }
.sp
twait(rendezvous<I0, I1> &\fIrendezvous\fB, I0 &\fIi0\fB, I1 &\fIi1\fB);
twait(rendezvous<I0> &\fIrendezvous\fB, I0 &\fIi0\fB);
twait(rendezvous<> &\fIrendezvous\fB);
.fi
.SH DESCRIPTION
.B Tamer
is a set of libraries and C++ language extensions designed to simplify the
practice of event-driven programming.
.LP
This manual page gives an overview of the
.B Tamer
abstractions, and describes the user-accessible
.B Tamer
methods and functions.
'
.SH OVERVIEW
.B Tamer
introduces four related abstractions for handling concurrency:
.IR events ,
.IR "wait points" ,
.IR rendezvous ", and"
.IR "safe local variables" .
.LP
Each 
.B event 
object represents a future occurrence, such as the completion of a network
read.  When the expected occurrence actually happens\*Efor instance, a
packet arrives\*Ethe event is 
.I triggered
via its
.B trigger
method.
.LP
The
.B make_event
function allocates an event of type
.BR event<T*> , 
where
.B T*
is a sequence of zero to four types determined by
.BR make_event 's
arguments.  This event's 
.B trigger
method has the signature
.B void trigger(T*).
Calling
.B trigger(\fIv*\fB)
marks the event as having occurred, and
passes zero to four results
.IR v* ,
which are called
.IR "trigger values" ,
to whomever is expecting the event.  The types of
.I v*
must match the event's types
.BR T* .
For example:
.nf
.sp
\fB  rendezvous<> \fIr\fB;  int \fIi\fB = 0;
  event<int> \fIe\fB = make_event(\fIr\fB, \fIi\fB);
  \fIe\fB.trigger(100);
  assert(\fIi\fB == 100);               // \fRassertion will succeed
.sp
.fi
When triggered, 
.IR e 's
.B int
trigger value is stored in
.IR i ,
the
.I trigger slot
passed to
.BR make_event
when the event was created.
The type of
.I i
is echoed in
.IR e 's
type
.BR event<int> .
.LP
.B event
objects may be freely assigned, passed as arguments, and copied via copy
constructors\*Eessentially, treated as primitive values.  They are
automatically reference counted.  Each
.B event
may be triggered at most once; second and subsequent trigger attempts have
no effect.
.LP
An event may be explicitly canceled by calling its
.B cancel
method.  Alternately, an event is automatically canceled when the last
reference to the event goes out of scope.  The
.B trigger
method has no effect on a canceled event.  It is possible to detect when an
event is canceled using the
.B event<T*>::at_cancel
method.  Consider the call
.BR \fIe\fB.at_cancel(\fIe2\fB) ,
where
.I e2
is an
.BR event<> .
If \fIe\fR is canceled before it is triggered,  then
.B Tamer
will automatically trigger
.IR e2 .
If, on the other hand, 
.I e
is triggered first, then
.B Tamer
will automatically cancel
.IR e2 .
.LP
The
.B wait point
language extension, written
.BR twait ,
blocks the calling function until one or more events are triggered.
Blocking causes a function to return to its caller, but its execution point
and safe local variables are preserved in memory.  When an expected event
occurs, the function \*(lqunblocks\*(rq and resumes processing at the wait
point.  By that time, of course, the function's original caller may have
returned.  Any function containing a wait point is marked with the
.B tamed
keyword, which informs the caller that the function can block.
.LP
The first, and more common, form of wait point is written
\*(lq\fBtwait\~{ \fIstatements\fB; }\fR\*(rq.
This executes the
.IR statements ,
then blocks until all events created by
.B make_event 
calls in the
.I statements
have triggered.  (Within the
.IR statements ,
.B make_event
is redefined to a macro that automatically supplies the initial
.B rendezvous
argument.)
For example, code like \*(lq\fBtwait { tamer::at_delay_sec(\fR10\fB, make_event()); }\fR\*(rq
should be read as \*(lqexecute \fBtamer::at_delay_sec(\fR10\fB, make_event())\fR,
then block until the created event has triggered\*(rq\*Eor,
since
.B tamer::at_delay_sec
triggers its event argument after the given number of seconds has passed, simply as \*(lqblock for 10 seconds\*(rq.
.LP
The second, more flexible form of wait point explicitly names a
.B rendezvous
object, which specifies the set of expected events relevant to the wait
point.  Every 
.B event
object associates with one 
.BR rendezvous .  
A wait point
.B twait(\fIr\fB)
unblocks when 
.I any one
of
.B rendezvous<>
.IR r 's
events occurs.  Unblocking consumes the event and restarts the blocked
function.
.\" The first form of wait point is actually syntactic sugar for
.\" the second: code like \*(lq\fBtwait\~{ \fIstatements\fB; }\fR\*(rq
.\" expands into something like
.\" .nf
.\" .sp
.\" \fB  rendezvous<> \fI__r\fB;
.\"   \fIstatements\fB;      // \fRwhere \fBmake_event\fR calls create events on \fI__r\fB
.\"   while (\fI__r\fB.nevents())
.\"       twait(\fI__r\fB);\fR
.\" .sp
.\" .fi
The 
.B twait()
form can also return information about
.I which
event occurred.  A rendezvous of type
.BR rendezvous<I*> , 
where 
.B I*
is zero to two types, associates
.I event IDs
of type(s)
.BR I*
with events.  The
.B make_event
function specifies event IDs as well as trigger slots.  A 
.B twait(\fIr\fB, \fIi*\fB)
statement sets the variable(s)
.I i*
to the ID(s) of the unblocking event.  The type(s) of
.I i*
must match the type(s) of the
.BR rendezvous .
.LP
.B rendezvous
objects are noncopyable: their copy constructors and assignment operators
are private.
.LP
A
.B tamed
function's caller resumes when the called function
.IR "either returns or blocks" .
To allow its caller to distinguish returning from blocking, a 
.B tamed
function will often accept an event argument, which it triggers when it
returns.  This trigger signals the function's completion.  Here is a
.B tamed
function that blocks, then returns an integer:
.nf
.sp
  \fBtamed void blockf(event<int> \fIdone\fB) {
      \&\fR... block ...\fB
      done.trigger(\fR200\fB);
  }\fR
.sp
.fi
A caller will most likely use
.B twait
to wait for
.B blockf
to return, and so become
.B tamed
itself.
Waiting for events thus trickles up the call stack until a caller
doesn't care whether its callee returns or blocks.
.LP
When an event
.I e
is triggered, 
.B Tamer
enqueues a
.I trigger notification
for 
.IR e 's
event ID on
.IR e 's
rendezvous
.IR r .
This step also unblocks any function blocked on
.BR twait(\fIr\fB) .
Conversely,
.B twait(\fIr\fB)
checks for any queued trigger notifications
.IR r .
If one exists, it is dequeued and returned.  Otherwise, the function blocks
at that wait point; it will unblock and recheck the rendezvous once someone
triggers a corresponding event.  The top-level event loop cycles through
unblocked functions, calling them in some order.
.LP
Multiple functions cannot simultaneously block on the same rendezvous.
.LP
Finally, 
.B safe local variables
are variables whose values are preserved across wait points.  The
programmer marks local variables as safe by enclosing them in a
.B tvars{}
block, which preserves their values in a heap-allocated closure.  Function
parameters are always safe.  Unsafe local variables have indeterminate
values after a wait point; if you need to mark a variable as safe, the C++
compiler will often give you an uninitialized-variable warning for that
variable.
'
.SH EVENT CLASS
The
.B event
template class represents future occurrences.  The template takes zero to
four type arguments, which represent the types of the
.BR event 's
trigger values.  In the following,
.B T0-T3
are the template arguments of the
.B event
type.  If given, these type arguments must be copy-constructible and
assignable.
.sp
.nf
.B event<T*>::event()
.fi
.RS 5
Creates an empty event.  Trigger attempts on the event are ignored;
.B \fIe\fB.empty()
returns true.
.RE
.sp
.nf
.B template <typename R, [typename I0, typename I1]>
.B event<T0, T1, T2, T3>::event(R &\fIr\fB, [const I0 &\fIi0\fB, const I1 &\fIi1\fB,]
.B "                             T0 &\fIs0\fB, T1 &\fIs1\fB, T2 &\fIs2\fB, T3 &\fIs3\fB)"
.B ... event<>::event(R &\fIr\fB, [const I0 &\fIi0\fB, const I1 &\fIi1\fB])
.fi
.RS 5
Creates an event on
.B rendezvous
.IR r
with optional event IDs
.IR i0 " and " i1
and trigger slots
.IR s0 ... s3 .
Each 
.B event
type has similar constructors whose slot arguments
.I s*
match the template arguments.
.RE
.sp
.nf
.B event<T*>::event(const event<T*> &\fIe\fR)
.B event<T*> &event<T*>::operator=(const event<T*> &\fIe\fR)
.fi
.RS 5
Events may be safely copied and assigned.  After an assignment
\fIe1\fB\~=\~\fIe2\fR, the event objects
.IR e1 " and " e2
refer to the same underlying event; for example, triggering either causes
both to become empty.
.RE
.sp
.nf
.B event<T*>::operator bool() const
.fi
.RS 5
Returns true if the event is ready to be triggered.  Canceled events, empty
events, and events that have already been triggered return false.
.RE
.sp
.nf
.B bool event<T*>::empty() const
.fi
.RS 5
Returns true if the event is empty, meaning it was created empty, it has
been canceled, or it has already been triggered.
\*(lq\fIe\fB.empty()\fR\*(rq is equivalent to \*(lq\fB!(bool)\fIe\fR\*(rq.
.RE
.sp
.nf
.B void event<T0, T1, T2, T3>::trigger(const T0 &\fIv0\fB, const T1 &\fIv1\fB,
.B "                                    const T2 &\fIv2\fB, const T3 &\fIv3\fB)"
.B ... void event<>::trigger()
.fi
.RS 5
Triggers the event.  If the event is empty, this does nothing; otherwise,
it assigns the event's trigger slots (defined at creation time) to the
trigger values
.IR v0 ... v3
and wakes the relevant blocked closure, if any.  Events become empty after
they are triggered.  Each
.B event
type has a similar
.B trigger
method whose value arguments
.I v*
match the template arguments.
.RE
.sp
.nf
.B void event<T*>::cancel()
.fi
.RS 5
Explicitly cancels the event.  If the event is empty (it has already
triggered or been canceled), this does nothing; otherwise, it informs the
event's
.B rendezvous 
that the event will never complete, and triggers any cancel notifications
previously attached with
.BR at_cancel .
.RE
.sp
.nf
.B void event<T*>::at_cancel(const event<> &\fIcancel_evt\fB)
.fi
.RS 5
Registers
.I cancel_evt
for cancel notification.  If this event is already empty,
.I cancel_evt
is triggered immediately.  Otherwise,
.I cancel_evt
is triggered when this event is canceled, and canceled when this event is
triggered.
.RE
'
.SH "RENDEZVOUS CLASS"
The
.B rendezvous
template class groups related events.  The template takes zero to
two type arguments, which represent the types of the
.BR rendezvous 's
event IDs.  In the following,
.BR I0 " and " I1
are the template arguments of the
.B rendezvous
type.  If given, these type arguments must be copy-constructible and
assignable.
.sp
.nf
.B rendezvous<I*>::rendezvous()
.fi
.RS 5
Creates a new rendezvous with no outstanding events.
.RE
.sp
.nf
.B unsigned rendezvous<I*>::nevents() const
.fi
.RS 5
Returns the count of outstanding events.  This includes events that have
not yet been triggered or canceled, and events that have been triggered,
but the trigger notification has not been collected yet.
.RE
.sp
.nf
.B unsigned rendezvous<I*>::nready() const
.fi
.RS 5
Returns the count of ready events.  An event is ready if it has been
triggered, but the trigger notification has not been collected yet.  The
.B rendezvous<I*>::join
method will return true only if
.B nready()
is greater than 0.
.RE
.sp
.B unsigned rendezvous<I*>::nwaiting() const
.fi
.RS 5
Returns the count of waiting events.  An event is waiting if it has not yet
been triggered or canceled.
.RE
.sp
.nf
.B bool rendezvous<I0, I1>::join(I0 &\fIi0\fB, I1 &\fIi1\fB)
.B bool rendezvous<I0>::join(I0 &\fIi0\fB)
.B bool rendezvous<>::join()
.fi
.RS 5
Collects a trigger notification, if any events have triggered but have not
yet been collected.  If a trigger notification is available, sets the event
ID argument(s)
.IR i0 " and " i1 ,
if any, to the collected event's ID(s) and returns true.  Otherwise,
returns false.  The
.B twait
special forms are built around calls to
.BR rendezvous<I*>::join .
.RE
'
.SH "EVENT MODIFIERS"
These operations manipulate events generically, for example by returning
one event that triggers two others.
.sp
.nf
.B event<> distribute(const event<> &\fIe1\fB, const event<> &\fIe2\fB)
.fi
.RS 5
Returns an event that distributes trigger operations over
.IR e1 " and " e2 .
Triggering the returned event will trigger both
.IR e1 " and " e2
automatically.  Canceling the returned event will release
its references to
.IR e1 " and " e2 ;
if those were the only references remaining, the events will be canceled as
usual.
.RE
.sp
.nf
.B event<> bind(const event<T0> &\fIe\fB, const T0 &\fIv0\fB)
.fi
.RS 5
Returns an event that, when triggered, will call
.BR \fIe\fB.trigger(\fIv0\fB) .
Additionally, if
.I e
is canceled, then the returned event will be canceled.
.RE
.sp
.nf
.B event<T0> ignore_slot(const event<> &\fIe\fB)
.fi
.RS 5
Returns an event that, when triggered, will call
.BR \fIe\fB.trigger() .
The returned event's trigger value is ignored.  Additionally, if
.I e
is canceled, then the returned event will be canceled.
.RE
.sp
.nf
.B event<> make_canceler(const event<T*> &\fIe\fB)
.fi
.RS 5
Returns an event that, when triggered, will call
.BR \fIe\fB.cancel() .
The returned event will be canceled itself if
.I e
is triggered or canceled first.
.RE
.sp
.nf
.B event<T*> spread_cancel(const event<U*> &\fIeto\fB, event<T*> \fIefrom\fB)
.fi
.RS 5
When
.I efrom
is canceled,
.I eto
will immediately be canceled as well.  Returns
.IR efrom .
'
.SH "DRIVER"
The
.B driver
class handles
.BR Tamer 's 
fundamental events: timers, signals, and file descriptors.  Most programs
will use the single
.B driver::main
object, which is accessed through top-level functions as follows.
.sp
.nf
.B void at_fd_read(int \fIfd\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
when
.I fd
becomes readable.
.I fd
must be a valid file descriptor less than
.BR FD_SETSIZE .
.RE
.sp
.nf
.B void at_fd_write(int \fIfd\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
when
.I fd
becomes writable.
.I fd
must be a valid file descriptor less than
.BR FD_SETSIZE .
.RE
.sp
.nf
.B void at_fd_close(int \fIfd\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
when
.I fd
is closed by
.BR tamer::fileio::close .
.RE
.sp
.nf
.B void at_time(const timeval &\fIexpiry\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
at time
.IR expiry .
(Actually, as with all timer events, the event is triggered on or after
.IR expiry ;
the system aims to trigger the event as soon as possible.)
.RE
.sp
.nf
.B void at_delay(const timeval &\fIdelay\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
after at least
.I delay
time has passed.  All delays are measured relative to the timestamp
.BR now() .
.RE
.sp
.nf
.B void at_delay(double \fIdelay\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
after at least
.I delay
seconds have passed.
.RE
.sp
.nf
.B void at_delay_sec(double \fIdelay\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
after at least
.I delay
seconds have passed.
.RE
.sp
.nf
.B void at_delay_msec(double \fIdelay\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
after at least
.I delay
milliseconds have passed.
.RE
.sp
.nf
.B void at_signal(int \fIsignal\fB, const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
if the
.I signal
occurs.  The event is not triggered directly inside the signal handler.
Rather, the signal handler marks the signal's occurrence, then blocks the
signal from further delivery.  The signal remains blocked until
.IR e
has been triggered and any corresponding closure has run (and possibly
registered another event to catch the signal).  Thus, programmers can
safely catch signals without race conditions.
.RE
.sp
.nf
.B void at_asap(const event<> &\fIe\fB)
.fi
.RS 5
Triggers event
.I e
on the next execution of
.BR Tamer 's
main loop.
.RE
.sp
.nf
.B const timeval &now()
.fi
.RS 5
Returns the current cached timestamp.
.RE
.sp
.nf
.B void once()
.fi
.RS 5
Runs through the driver's event loop once.  First, the driver removes any
canceled timer and file descriptor events.  Then, the driver calls
.BR select
and possibly blocks, waiting for the next event.  Then, the driver triggers
and runs the appropriate signal events, file descriptor events, timer
events, and ASAP events.  Each path through the event loop resets
.B now()
to the correct current value.
.RE
.sp
.nf
.B void loop()
.fi
.RS 5
Equivalent to \*(lq\fBwhile (1) once();\fR\*(rq.
.RE
'
.SH "CANCEL ADAPTERS"
These functions integrate timeouts, signals, and other forms of canceling
into existing events.  For example:
.sp
.nf
  \fBint \fIi\fB;  rendezvous<> \fIr\fB;
  event<int> \fIe\fB = add_timeout(\fIdelay\fB, make_event(\fIr\fB, \fIi\fB));\fR
.fi
.sp
The event on
.I r
is triggered on the first of the following events.
.IP \(bu 3
.I e
is triggered.
.I i
is set to
.IR e 's
trigger value.
.IP \(bu 3
.I e
is canceled.
.I i
is set to
.B \-ECANCELED
(or, equivalently,
.BR tamer::outcome::cancel ).
.IP \(bu 3
.I delay
seconds elapse.
.I i
is set to
.B \-ETIMEDOUT
(or, equivalently,
.BR tamer::outcome::timeout ).
.LP
Cancel adapters are available for cancellation, timeouts, and signals.
.sp
.nf
.B event<int> add_timeout(const timeval &\fIdelay\fB, event<int> \fIe\fB)
.B event<int> add_timeout_sec(int \fIdelay\fB, event<int> \fIe\fB)
.B event<int> add_timeout_msec(int \fIdelay\fB, event<int> \fIe\fB)
.fi
.RS 5
Returns a timeout-adapted version of
.IR e .
When the returned event is triggered,
.I e
is triggered with the same trigger value.
If, however, the timeout of
.I delay
expires first, then
.I e
is triggered with value
.BR \-ETIMEDOUT ;
and if the returned event is canceled,
.I e
is triggered with value
.BR \-ECANCELED .
.RE
.sp
.nf
.B event<int> add_signal(int \fIsignal\fB, event<int> \fIe\fB)
.B event<int> add_signal(const std::vector<int> &\fIsignals\fB, event<int> \fIe\fB)
.fi
.RS 5
Returns a signal-adapted version of
.IR e .
When the returned event is triggered,
.I e
is triggered with the same trigger value.
If, however, the
.I signal
(or one of the
.IR signals )
happens first, then
.I e
is triggered with value
.BR \-EINTR ;
and if the returned event is canceled,
.I e
is triggered with value
.BR \-ECANCELED .
.RE
.sp
.nf
.B event<int> add_cancel(event<int> \fIe\fB)
.fi
.RS 5
Returns a cancel-adapted version of
.IR e .
When the returned event is triggered,
.I e
is triggered with the same trigger value.
If, however, the returned event is canceled,
.I e
is triggered with value
.BR \-ECANCELED .
.RE
.PP
There is also a set of cancel adapters that don't set
.IR e 's
trigger value.  For example:
.sp
.nf
  \fBint \fIi\fB;  rendezvous<> \fIr\fB;
  event<int> \fIe\fB = with_timeout(\fIdelay\fB, make_event(\fIr\fB, \fIi\fB));\fR
.fi
.sp
The event on
.I r
is triggered on the first of the following events.
.IP \(bu 3
.I e
is triggered.
.I i
is set to
.IR e 's
trigger value.
.IP \(bu 3
.I e
is canceled or
.I delay
seconds elapse.
.I i
retains its initial value.
.PP
This style of cancel adapter can handle any event type, not just
.BR event<int> .
.sp
.nf
.B event<T*> with_timeout(const timeval &\fIdelay\fB, event<T*> \fIe\fB)
.B event<T*> with_timeout_sec(int \fIdelay\fB, event<T*> \fIe\fB)
.B event<T*> with_timeout_msec(int \fIdelay\fB, event<T*> \fIe\fB)
.B event<T*> with_signal(int \fIsignal\fB, event<T*> \fIe\fB)
.B event<T*> with_signal(const std::vector<int> &\fIsignals\fB, event<T*> \fIe\fB)
.B event<T*> with_cancel(event<T*> \fIe\fB)
.fi
.RS 5
Return cancel-adapted versions of
.IR e .
These functions are analogous to the
.B add_
versions above, but do not set any trigger values to indicate whether the
event triggered successfully.
.RE
.sp
.nf
.B event<T*> with_timeout(const timeval &\fIdelay\fB, event<T*> \fIe\fB, int &\fIresult\fB)
.B event<T*> with_timeout_sec(int \fIdelay\fB, event<T*> \fIe\fB, int &\fIresult\fB)
.B event<T*> with_timeout_msec(int \fIdelay\fB, event<T*> \fIe\fB, int &\fIresult\fB)
.B event<T*> with_signal(int \fIsignal\fB, event<T*> \fIe\fB, int &\fIresult\fB)
.B event<T*> with_signal(const std::vector<int> &\fIsignals\fB, event<T*> \fIe\fB,
.B "                      int &\fIresult\fB)"
.B event<T*> with_cancel(event<T*> \fIe\fB, int &\fIresult\fB)
.fi
.RS 5
Return cancel-adapted versions of
.IR e .
When
.I e
triggers, the
.I result
variable is set to one of the following constants to indicate why:
.RS 2
.IP "\fB0\fR" 15
if
.I e
triggered successfully.
.IP "\fB\-ECANCELED\fR" 15
if
.I e
canceled.
.IP "\fB\-ETIMEDOUT\fR" 15
if
.I e
timed out.
.IP "\fB\-EINTR\fR" 15
if
.I e
was interrupted by a signal.
.RE
.LP
The constants
.BR tamer::outcome:: { success ,
.BR cancel ,
.BR timeout ,
.BR signal }
may be used instead of the error values.
.RE
'
.SH "FILE I/O"
.BR Tamer 's
support for file I/O is available via
.BR "#include <tamer/fileio.hh>" .
Variants of the main I/O system calls are provided, most of them
nonblocking.  You can avoid the
.B tamer::fileio::
prefix via
.RB \*(lq "using namespace tamer::fileio" \*(rq.
.sp
.nf
.B #include <tamer/fileio.hh>

.B int fileio::make_nonblocking(int \fIfd\fB)
.fi
.RS 5
Makes I/O on
.I fd
nonblocking.  Returns
.B 0
on success and a negative error code, such as
.BR \-EINVAL ,
on error.
.RE
.sp
.nf
.B void fileio::open(const char *\fIfilename\fB, int \fIflags\fB, event<int> \fIdone\fB)
.B void fileio::open(const char *\fIfilename\fB, int \fIflags\fB, mode_t \fImode\fB,
.B "                  event<int> \fIdone\fB)"
.fi
.RS 5
Opens
.I filename
with
.I flags
and optional
.IR mode .
The resulting file descriptor is made nonblocking, then passed as a trigger
value to
.IR done .
On error,
.I done
is triggered with a negative error code, such as
.BR \-EPERM .
The current implementation of
.B open
actually blocks.  File descriptors returned by
.B tamer::fileio::open
should be closed with
.BR tamer::fileio::close .
.RE
.sp
.nf
.B void fileio::fstat(int \fIfd\fB, struct stat &\fIstat_out\fB, event<int> \fIdone\fB)
.fi
.RS 5
Calls
.BR fstat(\fIfd\fB) ,
storing the result in
.IR stat_out
and triggering
.I done
when complete.
.IR done 's
trigger value is
.B 0
on success and a negative error code, such as
.BR \-EBADF ,
on failure.  The current implementation of
.B fstat
actually blocks.
.RE
.sp
.nf
.B void fileio::read(int \fIfd\fB, void *\fIbuf\fB, size_t \fIsize\fB, ssize_t &\fIsize_out\fB,
.B "                  event<int> \fIdone\fB)"
.fi
.RS 5
Reads up to
.I size
bytes from
.I fd
into
.IR buf ,
triggering
.I done
when complete.  The number of bytes read is stored in
.IR size_out ,
which is kept up to date as reading progresses.
.IR done 's
trigger value is
.B 0
on successful completion and a negative error code, such as
.BR \-EIO ,
on failure.  End-of-file is represented by a trigger value of
.B 0
and a
.I size_out
value of 
.BR 0 .
The current implementation of
.B read
blocks on reads from disk file descriptors.
.RE
.sp
.nf
.B void fileio::write(int \fIfd\fB, const void *\fIbuf\fB, size_t \fIsize\fB,
.B "                   ssize_t &\fIsize_out\fB, event<int> \fIdone\fB)"
.fi
.RS 5
Writes up to
.I size
bytes from
.I buf
into
.IR fd ,
triggering
.I done
when complete.  The number of bytes written is stored in
.IR size_out ,
which is kept up to date as writing progresses.
.IR done 's
trigger value is
.B 0
on successful completion and a negative error code, such as
.BR \-EIO ,
on failure.  The current implementation of
.B read
blocks on writes from disk file descriptors.
.RE
.sp
.nf
.B void fileio::close(int \fIfd\fB)
.fi
.RS 5
Closes
.IR fd .
Any file descriptor used for nonblocking reads and/or writes should be
closed with
.BR tamer::fileio::close ,
which correctly calls
.B tamer::at_fd_close
handlers.
.RE
.sp
.nf
.B void fileio::pipe(int \fIfd_out\fB[2], event<int> \fIdone\fB)
.fi
.RS 5
Creates a nonblocking pipe, setting
.IB fd_out [0]
to the read end of the pipe and
.IB fd_out [1]
to the write end.  Signals completion by triggering
.I done
with trigger value
.B 0
on success and a negative error code on error.
.RE
.sp
.nf
.B void fileio::socket(int \fIdomain\fB, int \fItype\fB, int \fIprotocol\fB,
.B "                    event<int> \fIdone\fB)"
.fi
.RS 5
Creates a nonblocking socket.  The resulting file descriptor is passed as a
trigger value to
.IR done ;
on error,
.I done
is triggered with a negative error code.
.RE
.sp
.nf
.B void fileio::accept(int \fIlistenfd\fB, struct sockaddr *\fIname_out\fB, 
.B "                    socklen_t *\fInamelen_out\fB, event<int> \fIdone\fB)"
.fi
.RS 5
Accepts a new connection on listening socket
.IB listenfd .
If non-null, the
.I name_out
and
.I namelen_out
variables are filled in with the accepted connection's address.  The
resulting file descriptor is made nonblocking, then passed as a trigger
value to
.IR done ;
on error,
.I done
is triggered with a negative error code.
.RE
.sp
.nf
.B void fileio::connect(int \fIfd\fB, const struct sockaddr *\fIname\fB,
.B "                     socklen_t \fInamelen\fB, event<int> \fIdone\fB)"
.fi
.RS 5
Connects the socket file descriptor
.I fd
to the given address.  On successful completion,
.I done
is triggered with trigger value
.BR 0 ;
on error, it is triggered with a negative error code.
.RE
